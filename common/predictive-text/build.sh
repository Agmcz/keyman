#! /bin/bash
#
# Compiles the Language Modeling Layer for common use in predictive text and autocorrective applications.
# Designed for optimal compatibility with the Keyman Suite.
#

# Fails the build if a specified file does not exist.
assert ( ) {
  if ! [ -f "$1" ]; then
    fail "Build failed."
    exit 1
  fi
}

# A nice, extensible method for -clean operations.  Add to this as necessary.
clean ( ) {
  rm -rf "./build"
  if [ $? -ne 0 ]; then
    fail "Failed to erase the prior build."
  fi
}

display_usage ( ) {
  echo "build.sh [-clean]"
  echo
  echo "  -clean              to erase pre-existing build products before a re-build"
}

# Prints a nice, common error message.
fail ( ) {
  FAILURE_MSG="$1"
  if [[ "$FAILURE_MSG" == "" ]]; then
    FAILURE_MSG="Unknown failure."
  fi
  echo "${ERROR_RED}$FAILURE_MSG${NORMAL}"
  exit 1
}

# Wraps JavaScript code in a way that can be embedded in a worker.
# To get the inner source code, include the file generated by this function,
# then use name.toString() where `name` is the name passed into this
# function.
wrap_worker_code ( ) {
  name="$1"
  js="$2"
  echo "// Autogenerated code. Do not modify!"
  printf "function %s () {\n" "${name}"
  cat "${js}"
  printf "\n}\n"
}

################################ Main script ################################

echo "Node.js + dependencies check"
npm install --no-optional

if [ $? -ne 0 ]; then
  fail "Build environment setup error detected!  Please ensure Node.js is installed!"
fi

# Process command-line arguments
while [[ $# -gt 0 ]] ; do
  key="$1"
  case $key in
    -clean)
      clean
      ;;
  esac
  shift # past the processed argument
done

# Build worker first; main file depends on it.
# Then wrap the worker;
# Then build the main file.
npm run tsc -- -p ./worker/tsconfig.json &&\
  (wrap_worker_code LMLayerWorkerCode ./worker/index.js > embedded_worker.js) &&\
  npm run tsc 

if [ $? -ne 0 ]; then
  fail "Compilation failed."
fi

echo "Typescript compilation successful."
